
use pitch::{self, Hz};
use voice::{NoteHz, NoteState, Voice};
use time;

/// Types designed to modulate the state of a Node.
pub trait NoteFreqGenerator {
    /// The note frequency generated by the NoteFreqModulator type.
    type NoteFreq: NoteFreq;

    /// Construct a new note_freq from the note_hz given by a note_event and the last voice that
    /// handled a note.
    fn generate(&self,
                note_hz: NoteHz,
                detune: f32,
                voice: Option<&Voice<Self::NoteFreq>>) -> Self::NoteFreq;
}

/// Types to be generated by `NoteFreqGenerator` types.
pub trait NoteFreq: Clone {
    /// Step the NoteFreq forward one frame.
    fn step_frame(&mut self, _frame_ms: time::calc::Ms) {}
    /// Step the NoteFreq forward one frame and return the hz for the current frame.
    fn hz(&self) -> pitch::calc::Hz;
}


/// A PortamentoNote generator.
#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]
pub struct Portamento(pub f64);

/// A note that interpolates between to given frequencies over the given duration.
#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]
pub struct PortamentoFreq {
    current_ms: time::calc::Ms,
    target_ms: time::calc::Ms,
    start_mel: pitch::calc::Mel,
    target_mel: pitch::calc::Mel,
}


/// A wrapper for switching between NoteFreqGenerators at runtime.
#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]
pub enum DynamicGenerator {
    Portamento(Portamento),
    Constant,
}

/// A warpper for switching between different NoteFreqs at runtime.
#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]
pub enum Dynamic {
    Portamento(PortamentoFreq),
    Constant(pitch::calc::Hz),
}


impl DynamicGenerator {
    /// Construct a default portamento.
    pub fn portamento(ms: time::calc::Ms) -> DynamicGenerator {
        DynamicGenerator::Portamento(Portamento(ms))
    }
}


/// Generate a constant `Hz` frequency.
fn generate_constant_freq(note_hz: NoteHz, detune: f32) -> pitch::calc::Hz {
    // If some detune was given, slightly detune the note_hz.
    if detune > 0.0 {
        let step_offset = ::rand::random::<f32>() * 2.0 * detune - detune;
        pitch::Step(Hz(note_hz).step() + step_offset).hz()
    // Otherwise, our target_hz is the given note_hz.
    } else {
        note_hz
    }
}


/// Generate a portamento frequency.
fn generate_portamento_freq(portamento_ms: time::calc::Ms,
                            note_hz: NoteHz,
                            detune: f32,
                            maybe_last_hz: Option<pitch::calc::Hz>) -> PortamentoFreq {

    // If some detune was given, slightly detune the note_hz.
    let target_hz = generate_constant_freq(note_hz, detune);

    PortamentoFreq {
        current_ms: 0.0,
        target_ms: portamento_ms,
        start_mel: Hz(maybe_last_hz.unwrap_or(target_hz)).mel(),
        target_mel: Hz(target_hz).mel(),
    }
}


impl NoteFreqGenerator for () {
    type NoteFreq = pitch::calc::Hz;
    fn generate(&self,
                note_hz: NoteHz,
                detune: f32,
                _voice: Option<&Voice<pitch::calc::Hz>>) -> pitch::calc::Hz {
        generate_constant_freq(note_hz, detune)
    }
}

impl NoteFreq for pitch::calc::Hz {
    fn hz(&self) -> pitch::calc::Hz { *self }
}


impl NoteFreqGenerator for Portamento {
    type NoteFreq = PortamentoFreq;
    fn generate(&self,
                note_hz: NoteHz,
                detune: f32,
                maybe_voice: Option<&Voice<PortamentoFreq>>) -> PortamentoFreq {

        let Portamento(duration_ms) = *self;

        // If some note is already playing, take it to use for portamento.
        let maybe_last_hz = match maybe_voice {
            Some(voice) => match voice.maybe_note.as_ref() {
                Some(&(NoteState::Playing, _, ref porta_freq, _)) => Some(porta_freq.hz()),
                _ => None,
            },
            None => None,
        };

        generate_portamento_freq(duration_ms, note_hz, detune, maybe_last_hz)

    }
}

impl NoteFreq for PortamentoFreq {
    fn step_frame(&mut self, frame_ms: time::calc::Ms) {
        if self.current_ms < self.target_ms {
            self.current_ms += frame_ms;
        }
    }
    fn hz(&self) -> pitch::calc::Hz {
        if self.current_ms < self.target_ms {
            let perc = self.current_ms as f64 / self.target_ms as f64;
            let diff_mel = self.target_mel - self.start_mel;
            let perc_diff_mel = perc * diff_mel as f64;
            let mel = self.start_mel + perc_diff_mel as pitch::calc::Mel;
            pitch::Mel(mel).hz()
        } else {
            pitch::Mel(self.target_mel).hz()
        }
    }
}


impl NoteFreqGenerator for DynamicGenerator {
    type NoteFreq = Dynamic;
    fn generate(&self,
                note_hz: NoteHz,
                detune: f32,
                maybe_voice: Option<&Voice<Dynamic>>) -> Dynamic {
        match *self {
            DynamicGenerator::Portamento(Portamento(portamento_ms)) => {
                // If some note is already playing, take it to use for portamento.
                let maybe_last_hz = match maybe_voice {
                    Some(voice) => match voice.maybe_note.as_ref() {
                        Some(&(NoteState::Playing, _, ref porta_freq, _)) => Some(porta_freq.hz()),
                        _ => None,
                    },
                    None => None,
                };
                let freq = generate_portamento_freq(portamento_ms, note_hz, detune, maybe_last_hz);
                Dynamic::Portamento(freq)
            },
            DynamicGenerator::Constant =>
                Dynamic::Constant(generate_constant_freq(note_hz, detune)),
        }
    }
}

impl NoteFreq for Dynamic {
    fn step_frame(&mut self, frame_ms: time::calc::Ms) {
        match *self {
            Dynamic::Portamento(ref mut porta) => porta.step_frame(frame_ms),
            Dynamic::Constant(_)               => (),
        }
    }
    fn hz(&self) -> pitch::calc::Hz {
        match *self {
            Dynamic::Portamento(porta) => porta.hz(),
            Dynamic::Constant(hz)      => hz,
        }
    }
}
